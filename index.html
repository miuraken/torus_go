<!--
MIT License

Copyright (c) 2025 miuraken

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>トーラス碁盤</title> 
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        /* General body styling */
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Align content to the top */
            min-height: 100vh;
            background-color: #f0f4f8; /* Light blue-gray background */
            margin: 0;
            padding: 10px;
            box-sizing: border-box;
            overscroll-behavior: none; /* Prevent pull-to-refresh on mobile */
        }
        /* Main container for the game */
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #ffffff; /* White background for the container */
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1); /* Soft shadow for depth */
            width: 100%;
            max-width: 800px; /* Max width for larger screens */
        }
        /* Main title display */
        #mainTitle {
            font-size: 1.75rem; /* Tailwind text-2xl equivalent */
            font-weight: 600; /* Tailwind semibold */
            margin-bottom: 1rem; /* Tailwind mb-4 */
            color: #374151; /* Tailwind gray-700 */
        }

        .top-controls-wrapper {
            display: flex;
            flex-direction: column; 
            align-items: center;
            width: 100%;
            max-width: 550px; /* Adjusted for new button */
            margin-bottom: 10px;
        }
        .main-controls-row { /* For lang and history/3D */
            display: flex;
            justify-content: space-between;
            width: 100%;
            align-items: center;
            margin-bottom: 8px;
        }
        .language-controls {
            display: flex;
            gap: 10px; 
            align-items: center;
        }
        .language-controls label {
            cursor: pointer;
            font-size: 14px;
            color: #333;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .language-controls input[type="radio"] {
            cursor: pointer;
            margin-right: 3px;
        }
        .action-controls { /* For history and 3D buttons */
             display: flex;
            gap: 8px;
        }
        .action-controls button {
            padding: 6px 10px;
            font-size: 13px;
            border-radius: 6px;
            border: 1px solid #ccc;
            cursor: pointer;
            background-color: #f9f9f9;
            color: #333;
            transition: background-color 0.3s, border-color 0.3s;
        }
        .action-controls button:hover:not(:disabled) {
            background-color: #e9e9e9;
            border-color: #bbb;
        }
        .action-controls button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .canvas-area-wrapper {
            display: grid;
            grid-template-columns: auto 1fr auto; 
            grid-template-rows: auto 1fr auto;    
            align-items: center; 
            justify-items: center; 
            gap: 5px; 
            width: 100%; 
            margin-bottom: 10px; 
        }

        canvas#goBoard { /* Specific ID for 2D board */
            grid-column: 2 / 3; 
            grid-row: 2 / 3;    
            background-color: #e6bf83; 
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            cursor: pointer;
            display: block; 
            touch-action: none; 
        }

        .scroll-button {
            font-size: 20px; 
            background-color: #dddddd; 
            color: #333333;      
            border: none;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s;
            user-select: none; 
        }
        .scroll-button:hover {
            background-color: #cccccc; 
        }

        #scrollLeftBtn, #scrollRightBtn {
            width: 30px;       
            min-width: 30px;   
            padding-top: 8px;    
            padding-bottom: 8px; 
            padding-left: 4px;   
            padding-right: 4px;  
        }
        #scrollLeftBtn  { grid-column: 1 / 2; grid-row: 2 / 3; align-self: stretch; } 
        #scrollRightBtn { grid-column: 3 / 4; grid-row: 2 / 3; align-self: stretch; } 

        #scrollUpBtn, #scrollDownBtn {
            width: 100%; 
            padding-top: 4px;    
            padding-bottom: 4px; 
            padding-left: 8px;   
            padding-right: 8px;  
            min-height: 30px;   
            height: 30px;       
        }
        #scrollUpBtn    { grid-column: 2 / 3; grid-row: 1 / 2; } 
        #scrollDownBtn  { grid-column: 2 / 3; grid-row: 3 / 4; } 

        .board-size-controls {
            margin-top: 15px; 
            display: flex;
            gap: 8px;
            flex-wrap: wrap; 
            justify-content: center;
        }
        .board-size-controls button { 
            padding: 8px 12px;
            font-size: 14px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            background-color: #4a5568; 
            color: white;
            transition: background-color 0.3s;
        }
        .board-size-controls button:hover {
            background-color: #2d3748; 
        }
        .board-size-controls button.active { 
            background-color: #2c5282; 
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }

        .info-panel {
            display: flex;
            justify-content: space-around;
            width: 100%;
            max-width: 400px; 
            margin-top: 10px; 
            padding: 8px;
            background-color: #edf2f7; 
            border-radius: 8px;
            font-size: 14px;
        }
        .info-panel div {
            color: #2d3748; 
        }

        .message-area {
            margin-top: 10px;
            height: 20px; 
            font-size: 14px;
            color: #e53e3e; 
            font-weight: bold;
            text-align: center;
        }

        .instructions {
            margin-top:10px;
            font-size: 12px;
            color: #555; 
            text-align: center;
        }

        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000; 
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background-color: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            text-align: center;
            width: 90%;
            max-width: 400px;
        }
        .modal-content p {
            margin-bottom: 20px;
            font-size: 16px;
            color: #333;
        }
        .modal-buttons button {
            padding: 10px 20px;
            margin: 0 10px;
            border-radius: 6px;
            border: none;
            font-size: 15px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #modalConfirmBtn {
            background-color: #e53e3e; 
            color: white;
        }
        #modalConfirmBtn:hover {
            background-color: #c53030; 
        }
        #modalCancelBtn {
            background-color: #cbd5e0; 
            color: #2d3748;
        }
        #modalCancelBtn:hover {
            background-color: #a0aec0; 
        }

        /* 3D Modal Styles */
        #torus3DModal .modal-content {
            max-width: 90vw; 
            width: auto;
            height: 80vh; 
            display: flex; 
            flex-direction: column;
        }
        #torus3DCanvas {
            width: 100%;
            height: calc(100% - 40px); 
            display: block;
            border-radius: 6px;
        }
        #close3DModalBtn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.5);
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 20px;
            line-height: 30px;
            text-align: center;
            cursor: pointer;
        }

    </style>
</head>
<body>
    <div class="game-container">
        <h1 id="mainTitle">トーラス碁盤</h1> 
        <div class="top-controls-wrapper">
            <div class="main-controls-row">
                <div class="language-controls">
                    <label><input type="radio" name="language" value="en" id="langRadioEn"> EN</label>
                    <label><input type="radio" name="language" value="jp" id="langRadioJp"> JP</label>
                    <label><input type="radio" name="language" value="cn" id="langRadioCn"> CN</label>
                    <label><input type="radio" name="language" value="kr" id="langRadioKr"> KR</label>
                </div>
                <div class="action-controls">
                    <button id="undoBtn">戻る</button>
                    <button id="redoBtn">進む</button>
                    <button id="view3DBtn">3D</button> 
                </div>
            </div>
        </div>

        <div id="canvasAreaWrapper" class="canvas-area-wrapper">
            <div></div> <button id="scrollUpBtn" class="scroll-button">▲</button>
            <div></div> <button id="scrollLeftBtn" class="scroll-button">◀</button>
            <canvas id="goBoard" tabindex="0"></canvas> <button id="scrollRightBtn" class="scroll-button">▶</button>
            <div></div> <button id="scrollDownBtn" class="scroll-button">▼</button>
            <div></div> 
        </div>
        
        <div class="info-panel">
            <div id="currentPlayer">手番: 黒</div>
            <div id="blackCaptured">黒のアゲハマ: 0</div>
            <div id="whiteCaptured">白のアゲハマ: 0</div>
        </div>
        <div id="messageArea" class="message-area"></div>
        <div id="instructionsText" class="instructions">矢印キーまたは盤面周りのボタンでスクロールできます。赤い線が盤面の境界です。</div>

        <div class="board-size-controls">
            <button id="reset9x9Btn">9x9</button>
            <button id="reset13x13Btn">13x13</button>
            <button id="reset19x19Btn">19x19</button>
        </div>
    </div>

    <div id="resetConfirmModal" class="modal-overlay">
        <div class="modal-content">
            <p id="resetConfirmMessage">現在の盤面をリセットしますか？</p>
            <div class="modal-buttons">
                <button id="modalConfirmBtn">はい</button>
                <button id="modalCancelBtn">いいえ</button>
            </div>
        </div>
    </div>

    <div id="torus3DModal" class="modal-overlay">
        <div class="modal-content">
            <button id="close3DModalBtn">&times;</button>
            <canvas id="torus3DCanvas"></canvas>
        </div>
    </div>


    <script>
        // Get DOM elements
        const mainTitleElement = document.getElementById('mainTitle'); 
        const canvas = document.getElementById('goBoard'); // 2D canvas
        const ctx = canvas.getContext('2d');
        const currentPlayerDisplay = document.getElementById('currentPlayer');
        const blackCapturedDisplay = document.getElementById('blackCaptured');
        const whiteCapturedDisplay = document.getElementById('whiteCaptured');
        const messageArea = document.getElementById('messageArea');
        const canvasAreaWrapper = document.getElementById('canvasAreaWrapper');
        const instructionsTextElement = document.getElementById('instructionsText');

        const scrollUpBtn = document.getElementById('scrollUpBtn');
        const scrollDownBtn = document.getElementById('scrollDownBtn');
        const scrollLeftBtn = document.getElementById('scrollLeftBtn');
        const scrollRightBtn = document.getElementById('scrollRightBtn');

        const reset9x9Btn = document.getElementById('reset9x9Btn');
        const reset13x13Btn = document.getElementById('reset13x13Btn');
        const reset19x19Btn = document.getElementById('reset19x19Btn');
        const boardSizeButtons = [reset9x9Btn, reset13x13Btn, reset19x19Btn];

        const langRadioEn = document.getElementById('langRadioEn');
        const langRadioJp = document.getElementById('langRadioJp');
        const langRadioCn = document.getElementById('langRadioCn');
        const langRadioKr = document.getElementById('langRadioKr');
        const langRadios = [langRadioEn, langRadioJp, langRadioCn, langRadioKr];

        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        const view3DBtn = document.getElementById('view3DBtn'); // 3D View Button

        // Modal elements
        const resetConfirmModal = document.getElementById('resetConfirmModal');
        const resetConfirmMessage = document.getElementById('resetConfirmMessage');
        const modalConfirmBtn = document.getElementById('modalConfirmBtn');
        const modalCancelBtn = document.getElementById('modalCancelBtn');
        let confirmCallback = null; 

        // 3D Modal elements
        const torus3DModal = document.getElementById('torus3DModal');
        const torus3DCanvas = document.getElementById('torus3DCanvas');
        const close3DModalBtn = document.getElementById('close3DModalBtn');

        // Game constants
        const EMPTY = 0; 
        const BLACK = 1; 
        const WHITE = 2; 

        // Game state variables
        let boardSize = 9;       
        let cellSize;             
        let board;                
        let currentPlayer = BLACK; 
        let capturedStones = { [BLACK]: 0, [WHITE]: 0 }; 
        let koPosition = null;    
        
        let gameHistory = []; 
        let currentHistoryIndex = -1; 

        let offsetX = 0; 
        let offsetY = 0; 

        let touchStartX = 0;
        let touchStartY = 0;
        const tapThreshold = 10; 
        let tapTimeout = null;

        // Three.js variables
        let scene3D, camera3D, renderer3D, orbitControls3D, torusMesh3D, gridLinesGroup3D, stoneMeshes3D = []; 
        let targetTorusRotationX = 0;
        let targetTorusRotationY = 0;
        const rotationSpeed = 0.02;
        let animationFrameId3D; 


        const translations = {
            en: {
                title: "Torus Go Board", 
                mainTitle: "Torus Go Board", 
                currentPlayer: "Turn: ",
                blackCaptured: "Black Captured: ",
                whiteCaptured: "White Captured: ",
                reset9x9: "9x9", 
                reset13x13: "13x13",
                reset19x19: "19x19",
                errorStoneExists: "Stone already exists.",
                errorSuicide: "Suicide. Cannot place stone.",
                errorKo: "Ko. Cannot place stone.",
                errorUnexpected: "Error: Suicide (unexpected).",
                instructions: "Use arrow keys or buttons to scroll. Boundary lines are subtly marked.",
                black: "Black",
                white: "White",
                undo: "Undo",
                redo: "Redo",
                view3D: "3D View",
                confirmReset: "Reset the current board?",
                yes: "Yes",
                no: "No",
            },
            jp: { 
                title: "トーラス碁盤", 
                mainTitle: "トーラス碁盤", 
                currentPlayer: "手番: ",
                blackCaptured: "黒のアゲハマ: ",
                whiteCaptured: "白のアゲハマ: ",
                reset9x9: "9路盤", 
                reset13x13: "13路盤",
                reset19x19: "19路盤",
                errorStoneExists: "既に石があります。",
                errorSuicide: "自殺手です。着手できません。",
                errorKo: "コウです。着手できません。",
                errorUnexpected: "エラー: 自殺手です (予期せぬ状況)",
                instructions: "矢印キーまたは盤面周りのボタンでスクロールできます。境界線は薄く表示されます。",
                black: "黒",
                white: "白",
                undo: "戻る",
                redo: "進む",
                view3D: "3D表示",
                confirmReset: "現在の盤面をリセットしますか？",
                yes: "はい",
                no: "いいえ",
            },
            cn: { 
                title: "环形棋盘", 
                mainTitle: "环形棋盘", 
                currentPlayer: "执子: ",
                blackCaptured: "黑棋提子: ",
                whiteCaptured: "白棋提子: ",
                reset9x9: "9路",
                reset13x13: "13路",
                reset19x19: "19路",
                errorStoneExists: "此处已有棋子。",
                errorSuicide: "禁入点 (自杀)。",
                errorKo: "劫争。不能下子。",
                errorUnexpected: "错误：禁入点 (意外情况)。",
                instructions: "使用箭头键或棋盘周围的按钮滚动。边界线会以浅色标记。",
                black: "黑棋",
                white: "白棋",
                undo: "悔棋", 
                redo: "重做", 
                view3D: "3D视图",
                confirmReset: "要重置当前棋盘吗？",
                yes: "是",
                no: "否",
            },
            kr: { 
                title: "토러스 바둑판", 
                mainTitle: "토러스 바둑판", 
                currentPlayer: "차례: ",
                blackCaptured: "흑 잡은 돌: ",
                whiteCaptured: "백 잡은 돌: ",
                reset9x9: "9줄",
                reset13x13: "13줄",
                reset19x19: "19줄",
                errorStoneExists: "이미 돌이 있습니다.",
                errorSuicide: "자살수입니다. 둘 수 없습니다.",
                errorKo: "패입니다. 둘 수 없습니다.",
                errorUnexpected: "오류: 자살수 (예상치 못한 상황).",
                instructions: "화살표 키나 보드 주변 버튼으로 스크롤하세요. 경계선은 옅은 색으로 표시됩니다.",
                black: "흑",
                white: "백",
                undo: "무르기",
                redo: "다시 실행",
                view3D: "3D 보기",
                confirmReset: "현재 바둑판을 초기화하시겠습니까?",
                yes: "예",
                no: "아니오",
            }
        };
        let currentLanguage = 'jp'; 

        function setCookie(name, value, days) {
            let expires = "";
            if (days) {
                const date = new Date();
                date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                expires = "; expires=" + date.toUTCString();
            }
            document.cookie = name + "=" + (value || "")  + expires + "; path=/; SameSite=Lax";
        }

        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for(let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
            }
            return null;
        }

        function loadLanguagePreference() {
            const savedLang = getCookie("goGameLanguage");
            if (savedLang && translations[savedLang]) {
                currentLanguage = savedLang;
            } else {
                currentLanguage = 'jp'; 
            }
            langRadios.forEach(radio => {
                if (radio.value === currentLanguage) {
                    radio.checked = true;
                }
            });
        }

        function updateUIText() {
            const t = translations[currentLanguage]; 
            document.title = t.title; 
            mainTitleElement.textContent = t.mainTitle; 
            
            reset9x9Btn.textContent = t.reset9x9;
            reset13x13Btn.textContent = t.reset13x13;
            reset19x19Btn.textContent = t.reset19x19;
            
            instructionsTextElement.textContent = t.instructions;
            undoBtn.textContent = t.undo;
            redoBtn.textContent = t.redo;
            view3DBtn.textContent = t.view3D;

            resetConfirmMessage.textContent = t.confirmReset;
            modalConfirmBtn.textContent = t.yes;
            modalCancelBtn.textContent = t.no;
            
            langRadios.forEach(radio => {
                radio.checked = (radio.value === currentLanguage);
            });

            updateInfo(); 
        }

        function setLanguage(lang) {
            if (translations[lang]) { 
                currentLanguage = lang;
                setCookie("goGameLanguage", lang, 365); 
                updateUIText();
                clearMessage(); 
            }
        }

        function getAvailableGridDimension() { 
            const gameContainer = document.querySelector('.game-container');
            const mainTitleElem = document.getElementById('mainTitle'); 
            const topControlsWrapper = document.querySelector('.top-controls-wrapper');
            const boardSizeControlsElement = document.querySelector('.board-size-controls'); 
            const infoPanelElement = document.querySelector('.info-panel');
            const messageAreaElement = document.getElementById('messageArea');
            const instructionsElement = document.getElementById('instructionsText');

            const mainTitleStyle = mainTitleElem ? window.getComputedStyle(mainTitleElem) : { marginTop: '0px', marginBottom: '0px', height: '0px' };
            const topControlsStyle = topControlsWrapper ? window.getComputedStyle(topControlsWrapper) : { marginTop: '0px', marginBottom: '0px', height: '0px' };
            const boardSizeControlsStyle = boardSizeControlsElement ? window.getComputedStyle(boardSizeControlsElement) : { marginTop: '0px', marginBottom: '0px', height: '0px' };
            const infoPanelStyle = infoPanelElement ? window.getComputedStyle(infoPanelElement) : { marginTop: '0px', marginBottom: '0px', height: '0px' };
            const messageAreaStyle = messageAreaElement ? window.getComputedStyle(messageAreaElement) : { marginTop: '0px', marginBottom: '0px', height: '0px' };
            const instructionsStyle = instructionsElement ? window.getComputedStyle(instructionsElement) : { marginTop: '0px', marginBottom: '0px', height: '0px' };
            
            const gameContainerStyle = window.getComputedStyle(gameContainer);
            const bodyStyle = window.getComputedStyle(document.body);

            const mainTitleHeight = (mainTitleElem ? mainTitleElem.offsetHeight : 0) + parseFloat(mainTitleStyle.marginTop) + parseFloat(mainTitleStyle.marginBottom);
            const topControlsHeight = (topControlsWrapper ? topControlsWrapper.offsetHeight : 0) + parseFloat(topControlsStyle.marginTop) + parseFloat(topControlsStyle.marginBottom);
            const boardSizeControlsHeight = (boardSizeControlsElement ? boardSizeControlsElement.offsetHeight : 0) + parseFloat(boardSizeControlsStyle.marginTop) + parseFloat(boardSizeControlsStyle.marginBottom);
            const infoPanelHeight = (infoPanelElement ? infoPanelElement.offsetHeight : 0) + parseFloat(infoPanelStyle.marginTop) + parseFloat(infoPanelStyle.marginBottom);
            const messageAreaHeight = (messageAreaElement ? messageAreaElement.offsetHeight : 0) + parseFloat(messageAreaStyle.marginTop) + parseFloat(messageAreaStyle.marginBottom);
            const instructionsHeight = (instructionsElement ? instructionsElement.offsetHeight : 0) + parseFloat(instructionsStyle.marginTop) + parseFloat(instructionsStyle.marginBottom);
            
            const gameContainerVPadding = parseFloat(gameContainerStyle.paddingTop) + parseFloat(gameContainerStyle.paddingBottom);
            const gameContainerHPadding = parseFloat(gameContainerStyle.paddingLeft) + parseFloat(gameContainerStyle.paddingRight);
            const bodyVPadding = parseFloat(bodyStyle.paddingTop) + parseFloat(bodyStyle.paddingBottom);

            const availableHeightForWrapper = window.innerHeight - bodyVPadding - mainTitleHeight - topControlsHeight - boardSizeControlsHeight - infoPanelHeight - messageAreaHeight - instructionsHeight - gameContainerVPadding - parseFloat(window.getComputedStyle(canvasAreaWrapper).marginBottom);
            const availableWidthForWrapper = gameContainer.clientWidth - gameContainerHPadding;
            
            let targetDim = Math.min(availableWidthForWrapper, availableHeightForWrapper);
            targetDim = Math.max(0, targetDim); 
            
            return targetDim > 0 ? targetDim : 300; 
        }
        
        function recordHistory() {
            if (currentHistoryIndex < gameHistory.length - 1) {
                gameHistory = gameHistory.slice(0, currentHistoryIndex + 1);
            }

            const state = {
                board: JSON.parse(JSON.stringify(board)), 
                playerWhoseTurnItIs: currentPlayer, 
                captured: JSON.parse(JSON.stringify(capturedStones)), 
                ko: koPosition ? { ...koPosition } : null, 
            };
            gameHistory.push(state);
            currentHistoryIndex = gameHistory.length - 1;
            updateUndoRedoButtons();
        }

        function loadStateFromHistory(state, keepScroll = false) { 
            board = JSON.parse(JSON.stringify(state.board));
            currentPlayer = state.playerWhoseTurnItIs;
            capturedStones = JSON.parse(JSON.stringify(state.captured));
            koPosition = state.ko ? { ...state.ko } : null; 
            
            if (!keepScroll) { 
            }


            updateInfo();
            drawBoard(); 
            clearMessage();
            updateUndoRedoButtons();
            if (torus3DModal.classList.contains('active')) { 
                setup3DTorusAndBoard();
            }
        }

        function updateUndoRedoButtons() {
            undoBtn.disabled = currentHistoryIndex <= 0;
            redoBtn.disabled = currentHistoryIndex >= gameHistory.length - 1;
        }

        function undoMove() {
            if (currentHistoryIndex > 0) {
                currentHistoryIndex--;
                loadStateFromHistory(gameHistory[currentHistoryIndex], true); 
            }
        }

        function redoMove() {
            if (currentHistoryIndex < gameHistory.length - 1) {
                currentHistoryIndex++;
                loadStateFromHistory(gameHistory[currentHistoryIndex], true); 
            }
        }

        function showResetConfirmModal(onConfirm) {
            const t = translations[currentLanguage];
            resetConfirmMessage.textContent = t.confirmReset;
            modalConfirmBtn.textContent = t.yes;
            modalCancelBtn.textContent = t.no;
            resetConfirmModal.classList.add('active');
            confirmCallback = onConfirm;
        }

        function hideResetConfirmModal() {
            resetConfirmModal.classList.remove('active');
            confirmCallback = null;
        }
                
        // --- 3D Modal Functions ---
        function open3DModal() {
            torus3DModal.classList.add('active');
            if (!renderer3D) { 
                init3DScene();
            }
            setup3DTorusAndBoard(); 
            if(renderer3D && !animationFrameId3D) animate3D(); 
            document.addEventListener('keydown', handle3DKeyDown); 
        }

        function close3DModal() {
            torus3DModal.classList.remove('active');
            if (renderer3D && animationFrameId3D) { 
                cancelAnimationFrame(animationFrameId3D);
                animationFrameId3D = null;
            }
            document.removeEventListener('keydown', handle3DKeyDown); 
        }
        
        function init3DScene() {
            scene3D = new THREE.Scene();
            scene3D.background = new THREE.Color(0xf0f4f8); 

            const aspectRatio = torus3DCanvas.clientWidth / torus3DCanvas.clientHeight;
            camera3D = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000);
            camera3D.position.z = 15; 

            renderer3D = new THREE.WebGLRenderer({ canvas: torus3DCanvas, antialias: true, alpha: true });
            renderer3D.setSize(torus3DCanvas.clientWidth, torus3DCanvas.clientHeight);
            renderer3D.setPixelRatio(window.devicePixelRatio);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7); 
            scene3D.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9); 
            directionalLight.position.set(5, 10, 7.5);
            scene3D.add(directionalLight);

            orbitControls3D = new THREE.OrbitControls(camera3D, renderer3D.domElement);
            orbitControls3D.enableDamping = true;
            orbitControls3D.dampingFactor = 0.05;
            orbitControls3D.screenSpacePanning = false;
            orbitControls3D.minDistance = 5;
            orbitControls3D.maxDistance = 50;
        }

        function setup3DTorusAndBoard() {
            if (!scene3D) return;

            // Clear previous 3D objects
            stoneMeshes3D.forEach(s => { if(s.parent) s.parent.remove(s); }); 
            stoneMeshes3D = [];
            if (gridLinesGroup3D && gridLinesGroup3D.parent) { 
                 gridLinesGroup3D.parent.remove(gridLinesGroup3D);
            }
            gridLinesGroup3D = new THREE.Group(); 
            if (torusMesh3D && torusMesh3D.parent) {
                torusMesh3D.parent.remove(torusMesh3D);
            }


            const torusRadius = 5;
            const tubeRadius = 2;
            const radialSegments = 64; 
            const tubularSegments = 48; 

            const torusGeometry = new THREE.TorusGeometry(torusRadius, tubeRadius, radialSegments, tubularSegments);
            const torusMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xe6bf83, 
                transparent: true,
                opacity: 0.6, // Adjusted membrane opacity
                side: THREE.DoubleSide, 
                roughness: 0.7,
                metalness: 0.1
            });
            torusMesh3D = new THREE.Mesh(torusGeometry, torusMaterial);
            scene3D.add(torusMesh3D); 
            
            const R = torusRadius;
            const r_tube = tubeRadius;
            
            const lineMaterial = new THREE.MeshBasicMaterial({color: 0x66666644}); 
            const lineTubeRadius = 0.025; // Slightly thicker lines

            // Lines along parallels (rows)
            for (let i = 0; i < boardSize; i++) { 
                const vAngle = (i / boardSize) * Math.PI * 2;
                const pathPoints = [];
                for (let j = 0; j <= radialSegments; j++) { 
                    const uAngle = (j / radialSegments) * Math.PI * 2;
                    const x = (R + r_tube * Math.cos(vAngle)) * Math.cos(uAngle);
                    const y = (R + r_tube * Math.cos(vAngle)) * Math.sin(uAngle);
                    const z = r_tube * Math.sin(vAngle);
                    pathPoints.push(new THREE.Vector3(x, y, z));
                }
                const path = new THREE.CatmullRomCurve3(pathPoints, false); // Use CatmullRomCurve3 for smooth path
                const tubeGeom = new THREE.TubeGeometry(path, radialSegments, lineTubeRadius, 8, false); 
                const lineMesh = new THREE.Mesh(tubeGeom, lineMaterial);
                gridLinesGroup3D.add(lineMesh);
            }

            // Lines along meridians (columns)
            for (let i = 0; i < boardSize; i++) { 
                const uAngle = (i / boardSize) * Math.PI * 2;
                const pathPoints = [];
                for (let j = 0; j <= tubularSegments; j++) { 
                    const vAngle = (j / tubularSegments) * Math.PI * 2;
                    const x = (R + r_tube * Math.cos(vAngle)) * Math.cos(uAngle);
                    const y = (R + r_tube * Math.cos(vAngle)) * Math.sin(uAngle);
                    const z = r_tube * Math.sin(vAngle);
                    pathPoints.push(new THREE.Vector3(x, y, z));
                }
                const path = new THREE.CatmullRomCurve3(pathPoints, false);
                const tubeGeom = new THREE.TubeGeometry(path, tubularSegments, lineTubeRadius, 8, false); 
                const lineMesh = new THREE.Mesh(tubeGeom, lineMaterial);
                gridLinesGroup3D.add(lineMesh);
            }
            torusMesh3D.add(gridLinesGroup3D); 


            targetTorusRotationX = torusMesh3D.rotation.x; 
            targetTorusRotationY = torusMesh3D.rotation.y;

            const tubeCellLength = (2 * Math.PI * tubeRadius) / boardSize;
            const mainRingCellLength = (2 * Math.PI * torusRadius) / boardSize; 
            const stoneRadius = Math.min(tubeCellLength, mainRingCellLength) * 0.4; // Adjusted stone radius


            const blackMaterial = new THREE.MeshStandardMaterial({ color: 0x1a202c, roughness: 0.4, metalness: 0.1 });
            const whiteMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4, metalness: 0.1 });
            const stoneGeometry = new THREE.SphereGeometry(stoneRadius, 16, 16);

            for (let r = 0; r < boardSize; r++) {
                for (let c = 0; c < boardSize; c++) {
                    if (board[r][c] !== EMPTY) {
                        // Calculate u, v for the intersection point
                        const u = (c / boardSize) * Math.PI * 2; 
                        const v = (r / boardSize) * Math.PI * 2; 

                        const stone = new THREE.Mesh(stoneGeometry, board[r][c] === BLACK ? blackMaterial : whiteMaterial);
                        
                        // Position the stone directly on the surface of the torus at the intersection
                        stone.position.x = (R + r_tube * Math.cos(v)) * Math.cos(u);
                        stone.position.y = (R + r_tube * Math.cos(v)) * Math.sin(u);
                        stone.position.z = r_tube * Math.sin(v);
                        
                        torusMesh3D.add(stone); 
                        stoneMeshes3D.push(stone);
                    }
                }
            }
            targetTorusRotationY = -(offsetX / boardSize) * Math.PI * 2; 
            targetTorusRotationX = -(offsetY / boardSize) * Math.PI * 2; 
        }
        
        function animate3D() {
            animationFrameId3D = requestAnimationFrame(animate3D);
            if (orbitControls3D) orbitControls3D.update(); 

            if (torusMesh3D) {
                torusMesh3D.rotation.y += (targetTorusRotationY - torusMesh3D.rotation.y) * 0.1;
                torusMesh3D.rotation.x += (targetTorusRotationX - torusMesh3D.rotation.x) * 0.1;
            }

            if(renderer3D && scene3D && camera3D) renderer3D.render(scene3D, camera3D);
        }

        function handle3DKeyDown(event) {
            if (!torus3DModal.classList.contains('active')) return;
            let scrolled3D = false;
            const scrollAmount3D = (Math.PI * 2) / boardSize / 2; 

            switch (event.key) {
                case 'ArrowUp': targetTorusRotationX += scrollAmount3D; scrolled3D = true; break;
                case 'ArrowDown': targetTorusRotationX -= scrollAmount3D; scrolled3D = true; break;
                case 'ArrowLeft': targetTorusRotationY += scrollAmount3D; scrolled3D = true; break;
                case 'ArrowRight': targetTorusRotationY -= scrollAmount3D; scrolled3D = true; break;
            }
            if (scrolled3D) {
                event.preventDefault();
            }
        }

        function initBoard() {
            const wrapperDim = getAvailableGridDimension(); 
            canvasAreaWrapper.style.width = wrapperDim + 'px';
            canvasAreaWrapper.style.height = wrapperDim + 'px';

            const scrollButtonGap = 5; 
            const horizontalButtonTotalWidth = (scrollLeftBtn.offsetWidth || 30) + (scrollRightBtn.offsetWidth || 30) + (2 * scrollButtonGap);
            const verticalButtonTotalHeight = (scrollUpBtn.offsetHeight || 30) + (scrollDownBtn.offsetHeight || 30) + (2 * scrollButtonGap);

            const canvasAvailableWidth = wrapperDim - horizontalButtonTotalWidth;
            const canvasAvailableHeight = wrapperDim - verticalButtonTotalHeight;

            let canvasDrawingSize = Math.min(canvasAvailableWidth, canvasAvailableHeight); 
            canvasDrawingSize = Math.max(0, canvasDrawingSize); 

            if (boardSize <= 0) boardSize = 9; 
            
            canvas.width = Math.floor(canvasDrawingSize / boardSize) * boardSize;
            canvas.height = canvas.width; 

            if (canvas.width < boardSize * 10 && boardSize > 0) { 
                let fallbackCanvasSize = Math.min(
                    wrapperDim - horizontalButtonTotalWidth, 
                    wrapperDim - verticalButtonTotalHeight  
                );
                fallbackCanvasSize = Math.max(boardSize * 10, Math.floor(fallbackCanvasSize / boardSize) * boardSize);
                canvas.width = fallbackCanvasSize;
                canvas.height = fallbackCanvasSize;
            }
             if (canvas.width <= 0 && boardSize > 0) { 
                canvas.width = boardSize * 10;
                canvas.height = boardSize * 10;
            }

            cellSize = canvas.width / boardSize; 
             if (cellSize === 0 && boardSize > 0) { 
                cellSize = 10; 
                canvas.width = cellSize * boardSize;
                canvas.height = canvas.width;
            }

            board = Array(boardSize).fill(null).map(() => Array(boardSize).fill(EMPTY));
            currentPlayer = BLACK;
            capturedStones = { [BLACK]: 0, [WHITE]: 0 };
            koPosition = null; 
            offsetX = 0; 
            offsetY = 0; 
            
            gameHistory = []; 
            currentHistoryIndex = -1; 
            recordHistory(); 

            boardSizeButtons.forEach(btn => btn.classList.remove('active'));
            if (boardSize === 9) reset9x9Btn.classList.add('active');
            else if (boardSize === 13) reset13x13Btn.classList.add('active');
            else if (boardSize === 19) reset19x19Btn.classList.add('active');

            updateUIText(); 
            drawBoard();    
            clearMessage(); 
        }

        function drawBoard() {
            if (!ctx || !canvas || canvas.width === 0 || canvas.height === 0 || cellSize === 0) {
                return; 
            }
            ctx.clearRect(0, 0, canvas.width, canvas.height); 
            ctx.fillStyle = '#e6bf83'; 
            ctx.fillRect(0, 0, canvas.width, canvas.height); 

            const boundaryColor = '#ffffffbb'; 
            const boundaryLineWidth = Math.max(1, Math.floor(cellSize / 18)); 
            const normalLineColor = '#333';
            const normalLineWidth = Math.max(1, Math.floor(cellSize / 25));

            ctx.strokeStyle = normalLineColor;
            ctx.lineWidth = normalLineWidth;
            for (let i = 0; i < boardSize; i++) { 
                const xPos = cellSize / 2 + i * cellSize; 
                ctx.beginPath();
                ctx.moveTo(xPos, cellSize / 2);
                ctx.lineTo(xPos, canvas.height - cellSize / 2);
                ctx.stroke();
                
                const yPos = cellSize / 2 + i * cellSize; 
                ctx.beginPath();
                ctx.moveTo(cellSize / 2, yPos);
                ctx.lineTo(canvas.width - cellSize / 2, yPos);
                ctx.stroke();
            }

            ctx.strokeStyle = boundaryColor;
            ctx.lineWidth = boundaryLineWidth;

            for (let screenIndex = 0; screenIndex < boardSize; screenIndex++) {
                const logicalCol = (screenIndex + offsetX + boardSize) % boardSize;
                if (logicalCol === (boardSize - 1)) { 
                    const seamXPos = cellSize / 2 + screenIndex * cellSize + cellSize / 2; 
                    if (seamXPos > 0 && seamXPos < canvas.width) { 
                        ctx.beginPath();
                        ctx.moveTo(seamXPos, 0); 
                        ctx.lineTo(seamXPos, canvas.height);
                        ctx.stroke();
                    }
                }
            
                const logicalRow = (screenIndex + offsetY + boardSize) % boardSize;
                if (logicalRow === (boardSize - 1)) {
                    const seamYPos = cellSize / 2 + screenIndex * cellSize + cellSize / 2; 
                     if (seamYPos > 0 && seamYPos < canvas.height) { 
                        ctx.beginPath();
                        ctx.moveTo(0, seamYPos); 
                        ctx.lineTo(canvas.width, seamYPos);
                        ctx.stroke();
                    }
                }
            }

            const starPointSize = Math.max(1, cellSize / 12); 
            const starPoints = getStarPoints(boardSize); 
            ctx.fillStyle = '#333'; 
            starPoints.forEach(p_logical => {
                const screenX = (p_logical.x - offsetX + boardSize) % boardSize;
                const screenY = (p_logical.y - offsetY + boardSize) % boardSize;
                ctx.beginPath();
                ctx.arc(
                    cellSize / 2 + screenX * cellSize, 
                    cellSize / 2 + screenY * cellSize, 
                    starPointSize, 0, 2 * Math.PI);
                ctx.fill();
            });

            for (let dispY = 0; dispY < boardSize; dispY++) { 
                for (let dispX = 0; dispX < boardSize; dispX++) { 
                    const boardX = (dispX + offsetX + boardSize) % boardSize;
                    const boardY = (dispY + offsetY + boardSize) % boardSize;
                    if (board[boardY][boardX] !== EMPTY) { 
                        drawStone(boardX, boardY, board[boardY][boardX]); 
                    }
                }
            }
        }

        function getStarPoints(size) {
            if (size === 9) return [{x:2,y:2},{x:6,y:2},{x:4,y:4},{x:2,y:6},{x:6,y:6}];
            if (size === 13) return [{x:3,y:3},{x:9,y:3},{x:6,y:6},{x:3,y:9},{x:9,y:9}];
            if (size === 19) return [{x:3,y:3},{x:9,y:3},{x:15,y:3},{x:3,y:9},{x:9,y:9},{x:15,y:9},{x:3,y:15},{x:9,y:15},{x:15,y:15}];
            return []; 
        }

        function drawStone(boardX, boardY, color) {
            const screenX = (boardX - offsetX + boardSize) % boardSize;
            const screenY = (boardY - offsetY + boardSize) % boardSize;
            ctx.beginPath();
            ctx.arc(
                cellSize / 2 + screenX * cellSize, 
                cellSize / 2 + screenY * cellSize, 
                cellSize / 2 * 0.9, 
                0, 2 * Math.PI 
            );
            ctx.fillStyle = color === BLACK ? '#1a202c' : '#ffffff'; 
            ctx.fill();
            ctx.strokeStyle = color === BLACK ? '#000000' : '#cccccc'; 
            ctx.lineWidth = Math.max(0.5, Math.floor(cellSize / 50)); 
            ctx.stroke();
        }
        
        function processMove(x, y) { 
            const boardStateBeforePlayerPlacedStone = JSON.stringify(board); 

            const playerWhoMadeTheMove = currentPlayer;
            board[y][x] = playerWhoMadeTheMove; 

            let capturedGroups = []; 
            const opponent = playerWhoMadeTheMove === BLACK ? WHITE : BLACK;
            
            const neighbors = getNeighbors(x, y);
            for (const n of neighbors) {
                if (board[n.y][n.x] === opponent) {
                    const group = getGroup(n.x, n.y);
                    if (group.liberties === 0) {
                        let alreadyCounted = false;
                        for (const cg of capturedGroups) {
                            if (cg.stones.length > 0 && group.stones.length > 0 && cg.stones[0].x === group.stones[0].x && cg.stones[0].y === group.stones[0].y) {
                                alreadyCounted = true;
                                break;
                            }
                        }
                        if (!alreadyCounted) {
                            capturedGroups.push(group);
                        }
                    }
                }
            }

            let totalStonesCapturedThisMove = 0;
            if (capturedGroups.length > 0) {
                for (const group of capturedGroups) {
                    totalStonesCapturedThisMove += group.stones.length;
                    removeGroup(group.stones); 
                }
            }
            
            const ownGroupAfterPlacementAndCaptures = getGroup(x, y); 
            if (totalStonesCapturedThisMove === 0 && ownGroupAfterPlacementAndCaptures.liberties === 0) {
                board[y][x] = EMPTY; 
                showMessage("errorUnexpected"); 
                return; 
            }

            capturedStones[playerWhoMadeTheMove] += totalStonesCapturedThisMove;
            
            let koPointForNextPlayerRestriction = null; 
            if (totalStonesCapturedThisMove === 1 && capturedGroups.length === 1 && capturedGroups[0].stones.length === 1) {
                const singleCapturedStonePos = capturedGroups[0].stones[0]; 

                const tempBoardForKoCheck = JSON.parse(JSON.stringify(board)); 
                tempBoardForKoCheck[singleCapturedStonePos.y][singleCapturedStonePos.x] = opponent; 
                
                const groupOfOriginalMoversStone = getGroup(x, y, tempBoardForKoCheck, playerWhoMadeTheMove);
                if (groupOfOriginalMoversStone.stones.length === 1 && groupOfOriginalMoversStone.liberties === 0) {
                    tempBoardForKoCheck[y][x] = EMPTY; 
                    if (JSON.stringify(tempBoardForKoCheck) === boardStateBeforePlayerPlacedStone) {
                        koPointForNextPlayerRestriction = { x: singleCapturedStonePos.x, y: singleCapturedStonePos.y };
                    }
                }
            }
            
            currentPlayer = opponent; 
            koPosition = koPointForNextPlayerRestriction; 

            recordHistory(); 
            updateInfo();    
            drawBoard();     
            clearMessage();  
        }

        function handleInteraction(event) {
            if (cellSize === 0) return; 

            const rect = canvas.getBoundingClientRect(); 
            let clickXOnCanvas, clickYOnCanvas;

            if (event.type.startsWith('touch')) {
                if (event.touches.length === 0 && event.changedTouches.length === 0) return; 
                 const touch = event.touches[0] || event.changedTouches[0]; 
                clickXOnCanvas = touch.clientX - rect.left;
                clickYOnCanvas = touch.clientY - rect.top;
            } else { 
                clickXOnCanvas = event.clientX - rect.left;
                clickYOnCanvas = event.clientY - rect.top;
            }
            
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const logicalClickX = clickXOnCanvas * scaleX; 
            const logicalClickY = clickYOnCanvas * scaleY; 

            const screenCellX = Math.floor(logicalClickX / cellSize);
            const screenCellY = Math.floor(logicalClickY / cellSize);

            const x = (screenCellX + offsetX + boardSize) % boardSize; 
            const y = (screenCellY + offsetY + boardSize) % boardSize; 

            if (x < 0 || x >= boardSize || y < 0 || y >= boardSize) return; 
            
            if (isValidMove(x, y, currentPlayer)) {
                processMove(x, y); 
            }
        }

        function isValidMove(x, y, player) {
            if (board[y][x] !== EMPTY) { 
                showMessage("errorStoneExists"); 
                return false;
            }

            if (koPosition && koPosition.x === x && koPosition.y === y) {
                showMessage("errorKo"); 
                return false;
            }

            const tempBoard = JSON.parse(JSON.stringify(board)); 
            tempBoard[y][x] = player; 
            
            let capturesOpponent = false; 
            const opponent = player === BLACK ? WHITE : BLACK;
            const neighbors = getNeighbors(x, y); 

            for (const n of neighbors) {
                if (tempBoard[n.y][n.x] === opponent) {
                    const opponentGroup = getGroup(n.x, n.y, tempBoard, opponent);
                    if (opponentGroup.liberties === 0) {
                        capturesOpponent = true; 
                        opponentGroup.stones.forEach(s => tempBoard[s.y][s.x] = EMPTY);
                    }
                }
            }
            
            const ownGroup = getGroup(x, y, tempBoard, player); 
            if (ownGroup.liberties === 0 && !capturesOpponent) { 
                showMessage("errorSuicide"); 
                return false; 
            }

            clearMessage(); 
            return true; 
        }

        function getGroup(startX, startY, currentBoard = board, stoneColor = null) {
            if (startY < 0 || startY >= boardSize || startX < 0 || startX >= boardSize) {
                return { stones: [], liberties: 0, color: EMPTY }; 
            }

            const colorToFind = stoneColor !== null ? stoneColor : currentBoard[startY][startX];
            if (colorToFind === EMPTY) return { stones: [], liberties: 0, color: EMPTY }; 

            const q = [{x: startX, y: startY}]; 
            const groupStones = []; 
            const libertyCoords = new Set(); 
            const visited = Array(boardSize).fill(null).map(() => Array(boardSize).fill(false)); 
            
            if(currentBoard[startY][startX] !== colorToFind) { 
                return { stones: [], liberties: 0, color: colorToFind }; 
            }
            visited[startY][startX] = true;

            while (q.length > 0) {
                const {x, y} = q.shift(); 
                groupStones.push({x, y});

                const neighbors = getNeighbors(x, y); 
                for (const n of neighbors) {
                    if (currentBoard[n.y][n.x] === EMPTY) { 
                        libertyCoords.add(`${n.x},${n.y}`); 
                    } else if (currentBoard[n.y][n.x] === colorToFind && !visited[n.y][n.x]) { 
                        visited[n.y][n.x] = true;
                        q.push(n); 
                    }
                }
            }
            return { stones: groupStones, liberties: libertyCoords.size, color: colorToFind };
        }
        
        function removeGroup(stones) { 
            stones.forEach(s => {
                board[s.y][s.x] = EMPTY; 
            });
        }

        function getNeighbors(x, y) { 
            const neighbors = [];
            neighbors.push({x: (x - 1 + boardSize) % boardSize, y: y}); 
            neighbors.push({x: (x + 1) % boardSize, y: y});             
            neighbors.push({x: x, y: (y - 1 + boardSize) % boardSize}); 
            neighbors.push({x: x, y: (y + 1) % boardSize});             
            return neighbors;
        }

        function updateInfo() {
            const t = translations[currentLanguage]; 
            currentPlayerDisplay.textContent = t.currentPlayer + (currentPlayer === BLACK ? t.black : t.white);
            blackCapturedDisplay.textContent = t.blackCaptured + capturedStones[BLACK];
            whiteCapturedDisplay.textContent = t.whiteCaptured + capturedStones[WHITE];
        }
        
        function showMessage(messageKey) { 
            const t = translations[currentLanguage];
            messageArea.textContent = t[messageKey] || messageKey; 
        }

        function clearMessage() {
            messageArea.textContent = "";
        }

        function resetBoard(newSize) { 
            if (currentHistoryIndex > 0) { 
                showResetConfirmModal(() => { 
                    boardSize = newSize;
                    initBoard(); 
                });
            } else { 
                boardSize = newSize;
                initBoard();
            }
        };
        
        reset9x9Btn.onclick = () => resetBoard(9);
        reset13x13Btn.onclick = () => resetBoard(13);
        reset19x19Btn.onclick = () => resetBoard(19);

        langRadios.forEach(radio => {
            radio.addEventListener('change', (event) => {
                setLanguage(event.target.value);
            });
        });

        undoBtn.onclick = undoMove;
        redoBtn.onclick = redoMove;
        view3DBtn.onclick = open3DModal; 

        modalConfirmBtn.addEventListener('click', () => {
            if (confirmCallback) {
                confirmCallback();
            }
            hideResetConfirmModal();
        });

        modalCancelBtn.addEventListener('click', () => {
            hideResetConfirmModal();
        });

        resetConfirmModal.addEventListener('click', (event) => {
            if (event.target === resetConfirmModal) {
                hideResetConfirmModal();
            }
        });

        close3DModalBtn.addEventListener('click', close3DModal);
        torus3DModal.addEventListener('click', (event) => {
            if (event.target === torus3DModal) {
                close3DModal();
            }
        });


        canvas.addEventListener('keydown', (event) => {
            let scrolled = false; 
            switch (event.key) {
                case 'ArrowUp': offsetY = (offsetY - 1 + boardSize) % boardSize; scrolled = true; break; 
                case 'ArrowDown': offsetY = (offsetY + 1) % boardSize; scrolled = true; break; 
                case 'ArrowLeft': offsetX = (offsetX - 1 + boardSize) % boardSize; scrolled = true; break; 
                case 'ArrowRight': offsetX = (offsetX + 1) % boardSize; scrolled = true; break; 
            }
            if (scrolled) {
                event.preventDefault(); 
                drawBoard(); 
            }
        });

        scrollUpBtn.addEventListener('click', () => { 
            offsetY = (offsetY - 1 + boardSize) % boardSize; 
            drawBoard();
            canvas.focus(); 
        });
        scrollDownBtn.addEventListener('click', () => { 
            offsetY = (offsetY + 1) % boardSize; 
            drawBoard();
            canvas.focus();
        });
        scrollLeftBtn.addEventListener('click', () => { 
            offsetX = (offsetX - 1 + boardSize) % boardSize; 
            drawBoard();
            canvas.focus();
        });
        scrollRightBtn.addEventListener('click', () => { 
            offsetX = (offsetX + 1) % boardSize; 
            drawBoard();
            canvas.focus();
        });

        canvas.addEventListener('click', handleInteraction); 

        // tapTimeout is declared globally now
        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) { 
                touchStartX = e.touches[0].clientX; 
                touchStartY = e.touches[0].clientY;
                tapTimeout = setTimeout(() => { 
                    tapTimeout = null; 
                }, 200); 
            }
        }, { passive: true }); 

        canvas.addEventListener('touchend', (e) => {
            if (tapTimeout) { 
                clearTimeout(tapTimeout); 
                tapTimeout = null;
                const touchEndX = e.changedTouches[0].clientX; 
                const touchEndY = e.changedTouches[0].clientY;
                const deltaX = Math.abs(touchEndX - touchStartX); 
                const deltaY = Math.abs(touchEndY - touchStartY);
                if (deltaX < tapThreshold && deltaY < tapThreshold) { 
                    handleInteraction(e); 
                }
            }
        }, { passive: true });

        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout); 
            resizeTimeout = setTimeout(() => {
                initBoard(); 
                if (torus3DModal.classList.contains('active') && renderer3D) { 
                    const modalContent = torus3DCanvas.parentElement;
                    renderer3D.setSize(modalContent.clientWidth, modalContent.clientHeight - 40); 
                    camera3D.aspect = torus3DCanvas.clientWidth / torus3DCanvas.clientHeight;
                    camera3D.updateProjectionMatrix();
                    setup3DTorusAndBoard(); 
                }
            }, 250); 
        });
        
        loadLanguagePreference(); 
        initBoard(); 
        canvas.focus(); 
    </script>
</body>
</html>
