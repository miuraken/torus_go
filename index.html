<!--
MIT License

Copyright (c) 2025 miuraken

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>トーラス碁盤</title> <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* General body styling */
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Align content to the top */
            min-height: 100vh;
            background-color: #f0f4f8; /* Light blue-gray background */
            margin: 0;
            padding: 10px;
            box-sizing: border-box;
            overscroll-behavior: none; /* Prevent pull-to-refresh on mobile */
            /* overflow: hidden; /* Consider removing if zoom causes issues with body scroll */
        }
        /* Main container for the game */
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #ffffff; /* White background for the container */
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1); /* Soft shadow for depth */
            width: 100%;
            max-width: 800px; /* Max width for larger screens */
        }
        /* Main title display */
        #mainTitle {
            font-size: 1.75rem; /* Tailwind text-2xl equivalent */
            font-weight: 600; /* Tailwind semibold */
            margin-bottom: 1rem; /* Tailwind mb-4 */
            color: #374151; /* Tailwind gray-700 */
        }

        /* Controls for language selection - Radio button style */
        .top-controls-wrapper {
            display: flex;
            flex-direction: column; /* Stack language and history controls */
            align-items: center;
            width: 100%;
            max-width: 500px; /* Adjust as needed */
            margin-bottom: 10px;
        }
        .language-controls {
            display: flex;
            gap: 10px; 
            align-items: center;
            margin-bottom: 8px; /* Space between lang and history controls */
        }
        .language-controls label {
            cursor: pointer;
            font-size: 14px;
            color: #333;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .language-controls input[type="radio"] {
            cursor: pointer;
            margin-right: 3px;
        }
        .history-controls {
            display: flex;
            gap: 8px; /* Gap between undo/redo buttons */
        }
        .history-controls button {
            padding: 6px 10px;
            font-size: 13px;
            border-radius: 6px;
            border: 1px solid #ccc;
            cursor: pointer;
            background-color: #f9f9f9;
            color: #333;
            transition: background-color 0.3s, border-color 0.3s;
        }
        .history-controls button:hover:not(:disabled) {
            background-color: #e9e9e9;
            border-color: #bbb;
        }
        .history-controls button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }


        /* Wrapper for the canvas and scroll buttons, using CSS Grid */
        .canvas-area-wrapper {
            display: grid;
            grid-template-columns: auto 1fr auto; 
            grid-template-rows: auto 1fr auto;    
            align-items: center; 
            justify-items: center; 
            gap: 5px; 
            width: 100%; 
            margin-bottom: 10px; 
        }

        /* Go board canvas styling */
        canvas {
            grid-column: 2 / 3; 
            grid-row: 2 / 3;    
            background-color: #e6bf83; 
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            cursor: pointer;
            display: block; 
            touch-action: none; 
        }

        /* General styling for scroll buttons */
        .scroll-button {
            font-size: 20px; 
            background-color: #dddddd; 
            color: #333333;      
            border: none;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s;
            user-select: none; 
        }
        .scroll-button:hover {
            background-color: #cccccc; 
        }

        /* Specific styling for horizontal (left/right) scroll buttons */
        #scrollLeftBtn, #scrollRightBtn {
            width: 30px;       
            min-width: 30px;   
            padding-top: 8px;    
            padding-bottom: 8px; 
            padding-left: 4px;   
            padding-right: 4px;  
        }
        #scrollLeftBtn  { grid-column: 1 / 2; grid-row: 2 / 3; align-self: stretch; } 
        #scrollRightBtn { grid-column: 3 / 4; grid-row: 2 / 3; align-self: stretch; } 

        /* Specific styling for vertical (up/down) scroll buttons */
        #scrollUpBtn, #scrollDownBtn {
            width: 100%; 
            padding-top: 4px;    
            padding-bottom: 4px; 
            padding-left: 8px;   
            padding-right: 8px;  
            min-height: 30px;   
            height: 30px;       
        }
        #scrollUpBtn    { grid-column: 2 / 3; grid-row: 1 / 2; } 
        #scrollDownBtn  { grid-column: 2 / 3; grid-row: 3 / 4; } 

        /* Controls for resetting the board (9x9, 13x13, 19x19) - Moved to bottom */
        .board-size-controls {
            margin-top: 15px; 
            display: flex;
            gap: 8px;
            flex-wrap: wrap; 
            justify-content: center;
        }
        .board-size-controls button { 
            padding: 8px 12px;
            font-size: 14px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            background-color: #4a5568; 
            color: white;
            transition: background-color 0.3s;
        }
        .board-size-controls button:hover {
            background-color: #2d3748; 
        }
        .board-size-controls button.active { 
            background-color: #2c5282; 
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }


        /* Panel for displaying game information (current player, captures) */
        .info-panel {
            display: flex;
            justify-content: space-around;
            width: 100%;
            max-width: 400px; 
            margin-top: 10px; 
            padding: 8px;
            background-color: #edf2f7; 
            border-radius: 8px;
            font-size: 14px;
        }
        .info-panel div {
            color: #2d3748; 
        }

        /* Area for displaying messages (errors, ko warnings) */
        .message-area {
            margin-top: 10px;
            height: 20px; 
            font-size: 14px;
            color: #e53e3e; 
            font-weight: bold;
            text-align: center;
        }

        /* Text for game instructions */
        .instructions {
            margin-top:10px;
            font-size: 12px;
            color: #555; 
            text-align: center;
        }

        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000; /* Ensure it's on top */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background-color: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            text-align: center;
            width: 90%;
            max-width: 400px;
        }
        .modal-content p {
            margin-bottom: 20px;
            font-size: 16px;
            color: #333;
        }
        .modal-buttons button {
            padding: 10px 20px;
            margin: 0 10px;
            border-radius: 6px;
            border: none;
            font-size: 15px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #modalConfirmBtn {
            background-color: #e53e3e; /* Red */
            color: white;
        }
        #modalConfirmBtn:hover {
            background-color: #c53030; /* Darker Red */
        }
        #modalCancelBtn {
            background-color: #cbd5e0; /* Gray */
            color: #2d3748;
        }
        #modalCancelBtn:hover {
            background-color: #a0aec0; /* Darker Gray */
        }

    </style>
</head>
<body>
    <div class="game-container">
        <h1 id="mainTitle">トーラス碁盤</h1> 
        <div class="top-controls-wrapper">
            <div class="language-controls">
                <label><input type="radio" name="language" value="en" id="langRadioEn"> EN</label>
                <label><input type="radio" name="language" value="jp" id="langRadioJp"> JP</label>
                <label><input type="radio" name="language" value="cn" id="langRadioCn"> CN</label>
                <label><input type="radio" name="language" value="kr" id="langRadioKr"> KR</label>
            </div>
            <div class="history-controls">
                <button id="undoBtn">戻る</button>
                <button id="redoBtn">進む</button>
            </div>
        </div>

        <div id="canvasAreaWrapper" class="canvas-area-wrapper">
            <div></div> <button id="scrollUpBtn" class="scroll-button">▲</button>
            <div></div> <button id="scrollLeftBtn" class="scroll-button">◀</button>
            <canvas id="goBoard" tabindex="0"></canvas> <button id="scrollRightBtn" class="scroll-button">▶</button>
            <div></div> <button id="scrollDownBtn" class="scroll-button">▼</button>
            <div></div> 
        </div>
        
        <div class="info-panel">
            <div id="currentPlayer">手番: 黒</div>
            <div id="blackCaptured">黒のアゲハマ: 0</div>
            <div id="whiteCaptured">白のアゲハマ: 0</div>
        </div>
        <div id="messageArea" class="message-area"></div>
        <div id="instructionsText" class="instructions">矢印キーまたは盤面周りのボタンでスクロールできます。赤い線が盤面の境界です。</div>

        <div class="board-size-controls">
            <button id="reset9x9Btn">9x9</button>
            <button id="reset13x13Btn">13x13</button>
            <button id="reset19x19Btn">19x19</button>
        </div>
    </div>

    <div id="resetConfirmModal" class="modal-overlay">
        <div class="modal-content">
            <p id="resetConfirmMessage">現在の盤面をリセットしますか？</p>
            <div class="modal-buttons">
                <button id="modalConfirmBtn">はい</button>
                <button id="modalCancelBtn">いいえ</button>
            </div>
        </div>
    </div>

    <script>
        // Get DOM elements
        const mainTitleElement = document.getElementById('mainTitle'); 
        const canvas = document.getElementById('goBoard');
        const ctx = canvas.getContext('2d');
        const currentPlayerDisplay = document.getElementById('currentPlayer');
        const blackCapturedDisplay = document.getElementById('blackCaptured');
        const whiteCapturedDisplay = document.getElementById('whiteCaptured');
        const messageArea = document.getElementById('messageArea');
        const canvasAreaWrapper = document.getElementById('canvasAreaWrapper');
        const instructionsTextElement = document.getElementById('instructionsText');

        const scrollUpBtn = document.getElementById('scrollUpBtn');
        const scrollDownBtn = document.getElementById('scrollDownBtn');
        const scrollLeftBtn = document.getElementById('scrollLeftBtn');
        const scrollRightBtn = document.getElementById('scrollRightBtn');

        const reset9x9Btn = document.getElementById('reset9x9Btn');
        const reset13x13Btn = document.getElementById('reset13x13Btn');
        const reset19x19Btn = document.getElementById('reset19x19Btn');
        const boardSizeButtons = [reset9x9Btn, reset13x13Btn, reset19x19Btn];

        const langRadioEn = document.getElementById('langRadioEn');
        const langRadioJp = document.getElementById('langRadioJp');
        const langRadioCn = document.getElementById('langRadioCn');
        const langRadioKr = document.getElementById('langRadioKr');
        const langRadios = [langRadioEn, langRadioJp, langRadioCn, langRadioKr];

        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');

        // Modal elements
        const resetConfirmModal = document.getElementById('resetConfirmModal');
        const resetConfirmMessage = document.getElementById('resetConfirmMessage');
        const modalConfirmBtn = document.getElementById('modalConfirmBtn');
        const modalCancelBtn = document.getElementById('modalCancelBtn');
        let confirmCallback = null; // To store the action to perform on confirm

        // Game constants
        const EMPTY = 0; 
        const BLACK = 1; 
        const WHITE = 2; 

        // Game state variables
        let boardSize = 9;       
        let cellSize;             
        let board;                
        let currentPlayer = BLACK; 
        let capturedStones = { [BLACK]: 0, [WHITE]: 0 }; 
        let koPosition = null;    
        
        let gameHistory = []; 
        let currentHistoryIndex = -1; 

        let offsetX = 0; 
        let offsetY = 0; 

        let touchStartX = 0;
        let touchStartY = 0;
        const tapThreshold = 10; 

        const translations = {
            en: {
                title: "Torus Go Board", 
                mainTitle: "Torus Go Board", 
                currentPlayer: "Turn: ",
                blackCaptured: "Black Captured: ",
                whiteCaptured: "White Captured: ",
                reset9x9: "9x9", 
                reset13x13: "13x13",
                reset19x19: "19x19",
                errorStoneExists: "Stone already exists.",
                errorSuicide: "Suicide. Cannot place stone.",
                errorKo: "Ko. Cannot place stone.",
                errorUnexpected: "Error: Suicide (unexpected).",
                instructions: "Use arrow keys or buttons to scroll. Boundary lines are subtly marked.",
                black: "Black",
                white: "White",
                undo: "Undo",
                redo: "Redo",
                confirmReset: "Reset the current board?",
                yes: "Yes",
                no: "No",
            },
            jp: { 
                title: "トーラス碁盤", 
                mainTitle: "トーラス碁盤", 
                currentPlayer: "手番: ",
                blackCaptured: "黒のアゲハマ: ",
                whiteCaptured: "白のアゲハマ: ",
                reset9x9: "9路盤", 
                reset13x13: "13路盤",
                reset19x19: "19路盤",
                errorStoneExists: "既に石があります。",
                errorSuicide: "自殺手です。着手できません。",
                errorKo: "コウです。着手できません。",
                errorUnexpected: "エラー: 自殺手です (予期せぬ状況)",
                instructions: "矢印キーまたは盤面周りのボタンでスクロールできます。境界線は薄く表示されます。",
                black: "黒",
                white: "白",
                undo: "戻る",
                redo: "進む",
                confirmReset: "現在の盤面をリセットしますか？",
                yes: "はい",
                no: "いいえ",
            },
            cn: { 
                title: "环形棋盘", 
                mainTitle: "环形棋盘", 
                currentPlayer: "执子: ",
                blackCaptured: "黑棋提子: ",
                whiteCaptured: "白棋提子: ",
                reset9x9: "9路",
                reset13x13: "13路",
                reset19x19: "19路",
                errorStoneExists: "此处已有棋子。",
                errorSuicide: "禁入点 (自杀)。",
                errorKo: "劫争。不能下子。",
                errorUnexpected: "错误：禁入点 (意外情况)。",
                instructions: "使用箭头键或棋盘周围的按钮滚动。边界线会以浅色标记。",
                black: "黑棋",
                white: "白棋",
                undo: "悔棋", 
                redo: "重做", 
                confirmReset: "要重置当前棋盘吗？",
                yes: "是",
                no: "否",
            },
            kr: { 
                title: "토러스 바둑판", 
                mainTitle: "토러스 바둑판", 
                currentPlayer: "차례: ",
                blackCaptured: "흑 잡은 돌: ",
                whiteCaptured: "백 잡은 돌: ",
                reset9x9: "9줄",
                reset13x13: "13줄",
                reset19x19: "19줄",
                errorStoneExists: "이미 돌이 있습니다.",
                errorSuicide: "자살수입니다. 둘 수 없습니다.",
                errorKo: "패입니다. 둘 수 없습니다.",
                errorUnexpected: "오류: 자살수 (예상치 못한 상황).",
                instructions: "화살표 키나 보드 주변 버튼으로 스크롤하세요. 경계선은 옅은 색으로 표시됩니다.",
                black: "흑",
                white: "백",
                undo: "무르기",
                redo: "다시 실행",
                confirmReset: "현재 바둑판을 초기화하시겠습니까?",
                yes: "예",
                no: "아니오",
            }
        };
        let currentLanguage = 'jp'; 

        function setCookie(name, value, days) {
            let expires = "";
            if (days) {
                const date = new Date();
                date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                expires = "; expires=" + date.toUTCString();
            }
            document.cookie = name + "=" + (value || "")  + expires + "; path=/; SameSite=Lax";
        }

        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for(let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
            }
            return null;
        }

        function loadLanguagePreference() {
            const savedLang = getCookie("goGameLanguage");
            if (savedLang && translations[savedLang]) {
                currentLanguage = savedLang;
            } else {
                currentLanguage = 'jp'; 
            }
            langRadios.forEach(radio => {
                if (radio.value === currentLanguage) {
                    radio.checked = true;
                }
            });
        }

        function updateUIText() {
            const t = translations[currentLanguage]; 
            document.title = t.title; 
            mainTitleElement.textContent = t.mainTitle; 
            
            reset9x9Btn.textContent = t.reset9x9;
            reset13x13Btn.textContent = t.reset13x13;
            reset19x19Btn.textContent = t.reset19x19;
            
            instructionsTextElement.textContent = t.instructions;
            undoBtn.textContent = t.undo;
            redoBtn.textContent = t.redo;

            resetConfirmMessage.textContent = t.confirmReset;
            modalConfirmBtn.textContent = t.yes;
            modalCancelBtn.textContent = t.no;
            
            langRadios.forEach(radio => {
                radio.checked = (radio.value === currentLanguage);
            });

            updateInfo(); 
        }

        function setLanguage(lang) {
            if (translations[lang]) { 
                currentLanguage = lang;
                setCookie("goGameLanguage", lang, 365); 
                updateUIText();
                clearMessage(); 
            }
        }

        function getAvailableGridDimension() { 
            const gameContainer = document.querySelector('.game-container');
            const mainTitleElem = document.getElementById('mainTitle'); 
            const topControlsWrapper = document.querySelector('.top-controls-wrapper');
            const boardSizeControlsElement = document.querySelector('.board-size-controls'); 
            const infoPanelElement = document.querySelector('.info-panel');
            const messageAreaElement = document.getElementById('messageArea');
            const instructionsElement = document.getElementById('instructionsText');

            const mainTitleStyle = mainTitleElem ? window.getComputedStyle(mainTitleElem) : { marginTop: '0px', marginBottom: '0px', height: '0px' };
            const topControlsStyle = topControlsWrapper ? window.getComputedStyle(topControlsWrapper) : { marginTop: '0px', marginBottom: '0px', height: '0px' };
            const boardSizeControlsStyle = boardSizeControlsElement ? window.getComputedStyle(boardSizeControlsElement) : { marginTop: '0px', marginBottom: '0px', height: '0px' };
            const infoPanelStyle = infoPanelElement ? window.getComputedStyle(infoPanelElement) : { marginTop: '0px', marginBottom: '0px', height: '0px' };
            const messageAreaStyle = messageAreaElement ? window.getComputedStyle(messageAreaElement) : { marginTop: '0px', marginBottom: '0px', height: '0px' };
            const instructionsStyle = instructionsElement ? window.getComputedStyle(instructionsElement) : { marginTop: '0px', marginBottom: '0px', height: '0px' };
            
            const gameContainerStyle = window.getComputedStyle(gameContainer);
            const bodyStyle = window.getComputedStyle(document.body);

            const mainTitleHeight = (mainTitleElem ? mainTitleElem.offsetHeight : 0) + parseFloat(mainTitleStyle.marginTop) + parseFloat(mainTitleStyle.marginBottom);
            const topControlsHeight = (topControlsWrapper ? topControlsWrapper.offsetHeight : 0) + parseFloat(topControlsStyle.marginTop) + parseFloat(topControlsStyle.marginBottom);
            const boardSizeControlsHeight = (boardSizeControlsElement ? boardSizeControlsElement.offsetHeight : 0) + parseFloat(boardSizeControlsStyle.marginTop) + parseFloat(boardSizeControlsStyle.marginBottom);
            const infoPanelHeight = (infoPanelElement ? infoPanelElement.offsetHeight : 0) + parseFloat(infoPanelStyle.marginTop) + parseFloat(infoPanelStyle.marginBottom);
            const messageAreaHeight = (messageAreaElement ? messageAreaElement.offsetHeight : 0) + parseFloat(messageAreaStyle.marginTop) + parseFloat(messageAreaStyle.marginBottom);
            const instructionsHeight = (instructionsElement ? instructionsElement.offsetHeight : 0) + parseFloat(instructionsStyle.marginTop) + parseFloat(instructionsStyle.marginBottom);
            
            const gameContainerVPadding = parseFloat(gameContainerStyle.paddingTop) + parseFloat(gameContainerStyle.paddingBottom);
            const gameContainerHPadding = parseFloat(gameContainerStyle.paddingLeft) + parseFloat(gameContainerStyle.paddingRight);
            const bodyVPadding = parseFloat(bodyStyle.paddingTop) + parseFloat(bodyStyle.paddingBottom);

            const availableHeightForWrapper = window.innerHeight - bodyVPadding - mainTitleHeight - topControlsHeight - boardSizeControlsHeight - infoPanelHeight - messageAreaHeight - instructionsHeight - gameContainerVPadding - parseFloat(window.getComputedStyle(canvasAreaWrapper).marginBottom);
            const availableWidthForWrapper = gameContainer.clientWidth - gameContainerHPadding;
            
            let targetDim = Math.min(availableWidthForWrapper, availableHeightForWrapper);
            targetDim = Math.max(0, targetDim); 
            
            return targetDim > 0 ? targetDim : 300; 
        }
        
        function recordHistory() {
            if (currentHistoryIndex < gameHistory.length - 1) {
                gameHistory = gameHistory.slice(0, currentHistoryIndex + 1);
            }

            const state = {
                board: JSON.parse(JSON.stringify(board)), 
                playerWhoseTurnItIs: currentPlayer, 
                captured: JSON.parse(JSON.stringify(capturedStones)), 
                ko: koPosition ? { ...koPosition } : null, 
            };
            gameHistory.push(state);
            currentHistoryIndex = gameHistory.length - 1;
            updateUndoRedoButtons();
        }

        function loadStateFromHistory(state) {
            board = JSON.parse(JSON.stringify(state.board));
            currentPlayer = state.playerWhoseTurnItIs;
            capturedStones = JSON.parse(JSON.stringify(state.captured));
            koPosition = state.ko ? { ...state.ko } : null; 

            updateInfo();
            drawBoard(); 
            clearMessage();
            updateUndoRedoButtons();
        }

        function updateUndoRedoButtons() {
            undoBtn.disabled = currentHistoryIndex <= 0;
            redoBtn.disabled = currentHistoryIndex >= gameHistory.length - 1;
        }

        function undoMove() {
            if (currentHistoryIndex > 0) {
                currentHistoryIndex--;
                loadStateFromHistory(gameHistory[currentHistoryIndex]);
            }
        }

        function redoMove() {
            if (currentHistoryIndex < gameHistory.length - 1) {
                currentHistoryIndex++;
                loadStateFromHistory(gameHistory[currentHistoryIndex]);
            }
        }

        function showResetConfirmModal(onConfirm) {
            const t = translations[currentLanguage];
            resetConfirmMessage.textContent = t.confirmReset;
            modalConfirmBtn.textContent = t.yes;
            modalCancelBtn.textContent = t.no;
            resetConfirmModal.classList.add('active');
            confirmCallback = onConfirm;
        }

        function hideResetConfirmModal() {
            resetConfirmModal.classList.remove('active');
            confirmCallback = null;
        }

        modalConfirmBtn.addEventListener('click', () => {
            if (confirmCallback) {
                confirmCallback();
            }
            hideResetConfirmModal();
        });

        modalCancelBtn.addEventListener('click', () => {
            hideResetConfirmModal();
        });

        resetConfirmModal.addEventListener('click', (event) => {
            if (event.target === resetConfirmModal) {
                hideResetConfirmModal();
            }
        });


        function initBoard() {
            const wrapperDim = getAvailableGridDimension(); 
            canvasAreaWrapper.style.width = wrapperDim + 'px';
            canvasAreaWrapper.style.height = wrapperDim + 'px';

            const scrollButtonGap = 5; 
            const horizontalButtonTotalWidth = (scrollLeftBtn.offsetWidth || 30) + (scrollRightBtn.offsetWidth || 30) + (2 * scrollButtonGap);
            const verticalButtonTotalHeight = (scrollUpBtn.offsetHeight || 30) + (scrollDownBtn.offsetHeight || 30) + (2 * scrollButtonGap);

            const canvasAvailableWidth = wrapperDim - horizontalButtonTotalWidth;
            const canvasAvailableHeight = wrapperDim - verticalButtonTotalHeight;

            let canvasDrawingSize = Math.min(canvasAvailableWidth, canvasAvailableHeight); 
            canvasDrawingSize = Math.max(0, canvasDrawingSize); 

            if (boardSize <= 0) boardSize = 9; 
            
            canvas.width = Math.floor(canvasDrawingSize / boardSize) * boardSize;
            canvas.height = canvas.width; 

            if (canvas.width < boardSize * 10 && boardSize > 0) { 
                let fallbackCanvasSize = Math.min(
                    wrapperDim - horizontalButtonTotalWidth, 
                    wrapperDim - verticalButtonTotalHeight  
                );
                fallbackCanvasSize = Math.max(boardSize * 10, Math.floor(fallbackCanvasSize / boardSize) * boardSize);
                canvas.width = fallbackCanvasSize;
                canvas.height = fallbackCanvasSize;
            }
             if (canvas.width <= 0 && boardSize > 0) { 
                canvas.width = boardSize * 10;
                canvas.height = boardSize * 10;
            }

            cellSize = canvas.width / boardSize; 
             if (cellSize === 0 && boardSize > 0) { 
                cellSize = 10; 
                canvas.width = cellSize * boardSize;
                canvas.height = canvas.width;
            }

            board = Array(boardSize).fill(null).map(() => Array(boardSize).fill(EMPTY));
            currentPlayer = BLACK;
            capturedStones = { [BLACK]: 0, [WHITE]: 0 };
            koPosition = null; 
            offsetX = 0; 
            offsetY = 0; 
            
            gameHistory = []; 
            currentHistoryIndex = -1; 
            recordHistory(); 

            boardSizeButtons.forEach(btn => btn.classList.remove('active'));
            if (boardSize === 9) reset9x9Btn.classList.add('active');
            else if (boardSize === 13) reset13x13Btn.classList.add('active');
            else if (boardSize === 19) reset19x19Btn.classList.add('active');

            updateUIText(); 
            drawBoard();    
            clearMessage(); 
        }

        function drawBoard() {
            if (!ctx || !canvas || canvas.width === 0 || canvas.height === 0 || cellSize === 0) {
                return; 
            }
            ctx.clearRect(0, 0, canvas.width, canvas.height); 
            ctx.fillStyle = '#e6bf83'; 
            ctx.fillRect(0, 0, canvas.width, canvas.height); 

            const boundaryColor = '#ffffffbb'; 
            const boundaryLineWidth = Math.max(1, Math.floor(cellSize / 18)); 
            const normalLineColor = '#333';
            const normalLineWidth = Math.max(1, Math.floor(cellSize / 25));

            // Draw normal grid lines first
            ctx.strokeStyle = normalLineColor;
            ctx.lineWidth = normalLineWidth;
            for (let i = 0; i < boardSize; i++) { 
                const xPos = cellSize / 2 + i * cellSize; 
                ctx.beginPath();
                ctx.moveTo(xPos, cellSize / 2);
                ctx.lineTo(xPos, canvas.height - cellSize / 2);
                ctx.stroke();
                
                const yPos = cellSize / 2 + i * cellSize; 
                ctx.beginPath();
                ctx.moveTo(cellSize / 2, yPos);
                ctx.lineTo(canvas.width - cellSize / 2, yPos);
                ctx.stroke();
            }

            // Draw boundary "seam" lines using the user-provided logic
            ctx.strokeStyle = boundaryColor;
            ctx.lineWidth = boundaryLineWidth;

            // Check if the vertical seam is visible
            for (let screenCol = 0; screenCol < boardSize; screenCol++) {
                const logicalCol = (screenCol + offsetX + boardSize) % boardSize;
                if (logicalCol === (boardSize - 1)) {
                    const seamXPos = cellSize / 2 + screenCol * cellSize + cellSize / 2; 
                    if (seamXPos > 0 && seamXPos < canvas.width) { 
                        ctx.beginPath();
                        ctx.moveTo(seamXPos, 0); 
                        ctx.lineTo(seamXPos, canvas.height);
                        ctx.stroke();
                    }
                }
            }
            
            // Check if the horizontal seam is visible
            for (let screenRow = 0; screenRow < boardSize; screenRow++) {
                const logicalRow = (screenRow + offsetY + boardSize) % boardSize;
                if (logicalRow === (boardSize - 1)) {
                    const seamYPos = cellSize / 2 + screenRow * cellSize + cellSize / 2; 
                     if (seamYPos > 0 && seamYPos < canvas.height) { 
                        ctx.beginPath();
                        ctx.moveTo(0, seamYPos); 
                        ctx.lineTo(canvas.width, seamYPos);
                        ctx.stroke();
                    }
                }
            }


            const starPointSize = Math.max(1, cellSize / 12); 
            const starPoints = getStarPoints(boardSize); 
            ctx.fillStyle = '#333'; 
            starPoints.forEach(p_logical => {
                const screenX = (p_logical.x - offsetX + boardSize) % boardSize;
                const screenY = (p_logical.y - offsetY + boardSize) % boardSize;
                ctx.beginPath();
                ctx.arc(
                    cellSize / 2 + screenX * cellSize, 
                    cellSize / 2 + screenY * cellSize, 
                    starPointSize, 0, 2 * Math.PI);
                ctx.fill();
            });

            for (let dispY = 0; dispY < boardSize; dispY++) { 
                for (let dispX = 0; dispX < boardSize; dispX++) { 
                    const boardX = (dispX + offsetX + boardSize) % boardSize;
                    const boardY = (dispY + offsetY + boardSize) % boardSize;
                    if (board[boardY][boardX] !== EMPTY) { 
                        drawStone(boardX, boardY, board[boardY][boardX]); 
                    }
                }
            }
        }

        function getStarPoints(size) {
            if (size === 9) return [{x:2,y:2},{x:6,y:2},{x:4,y:4},{x:2,y:6},{x:6,y:6}];
            if (size === 13) return [{x:3,y:3},{x:9,y:3},{x:6,y:6},{x:3,y:9},{x:9,y:9}];
            if (size === 19) return [{x:3,y:3},{x:9,y:3},{x:15,y:3},{x:3,y:9},{x:9,y:9},{x:15,y:9},{x:3,y:15},{x:9,y:15},{x:15,y:15}];
            return []; 
        }

        function drawStone(boardX, boardY, color) {
            const screenX = (boardX - offsetX + boardSize) % boardSize;
            const screenY = (boardY - offsetY + boardSize) % boardSize;
            ctx.beginPath();
            ctx.arc(
                cellSize / 2 + screenX * cellSize, 
                cellSize / 2 + screenY * cellSize, 
                cellSize / 2 * 0.9, 
                0, 2 * Math.PI 
            );
            ctx.fillStyle = color === BLACK ? '#1a202c' : '#ffffff'; 
            ctx.fill();
            ctx.strokeStyle = color === BLACK ? '#000000' : '#cccccc'; 
            ctx.lineWidth = Math.max(0.5, Math.floor(cellSize / 50)); 
            ctx.stroke();
        }
        
        function processMove(x, y) { 
            const boardStateBeforePlayerPlacedStone = JSON.stringify(board); 

            const playerWhoMadeTheMove = currentPlayer;
            board[y][x] = playerWhoMadeTheMove; 

            let capturedGroups = []; 
            const opponent = playerWhoMadeTheMove === BLACK ? WHITE : BLACK;
            
            const neighbors = getNeighbors(x, y);
            for (const n of neighbors) {
                if (board[n.y][n.x] === opponent) {
                    const group = getGroup(n.x, n.y);
                    if (group.liberties === 0) {
                        let alreadyCounted = false;
                        for (const cg of capturedGroups) {
                            if (cg.stones.length > 0 && group.stones.length > 0 && cg.stones[0].x === group.stones[0].x && cg.stones[0].y === group.stones[0].y) {
                                alreadyCounted = true;
                                break;
                            }
                        }
                        if (!alreadyCounted) {
                            capturedGroups.push(group);
                        }
                    }
                }
            }

            let totalStonesCapturedThisMove = 0;
            if (capturedGroups.length > 0) {
                for (const group of capturedGroups) {
                    totalStonesCapturedThisMove += group.stones.length;
                    removeGroup(group.stones); 
                }
            }
            
            const ownGroupAfterPlacementAndCaptures = getGroup(x, y); 
            if (totalStonesCapturedThisMove === 0 && ownGroupAfterPlacementAndCaptures.liberties === 0) {
                board[y][x] = EMPTY; 
                showMessage("errorUnexpected"); 
                return; 
            }

            capturedStones[playerWhoMadeTheMove] += totalStonesCapturedThisMove;
            
            let koPointForNextPlayerRestriction = null; 
            if (totalStonesCapturedThisMove === 1 && capturedGroups.length === 1 && capturedGroups[0].stones.length === 1) {
                const singleCapturedStonePos = capturedGroups[0].stones[0]; 

                const tempBoardForKoCheck = JSON.parse(JSON.stringify(board)); 
                tempBoardForKoCheck[singleCapturedStonePos.y][singleCapturedStonePos.x] = opponent; 
                
                const groupOfOriginalMoversStone = getGroup(x, y, tempBoardForKoCheck, playerWhoMadeTheMove);
                if (groupOfOriginalMoversStone.stones.length === 1 && groupOfOriginalMoversStone.liberties === 0) {
                    tempBoardForKoCheck[y][x] = EMPTY; 
                    if (JSON.stringify(tempBoardForKoCheck) === boardStateBeforePlayerPlacedStone) {
                        koPointForNextPlayerRestriction = { x: singleCapturedStonePos.x, y: singleCapturedStonePos.y };
                    }
                }
            }
            
            currentPlayer = opponent; 
            koPosition = koPointForNextPlayerRestriction; 

            recordHistory(); 
            updateInfo();    
            drawBoard();     
            clearMessage();  
        }

        function handleInteraction(event) {
            if (cellSize === 0) return; 

            const rect = canvas.getBoundingClientRect(); 
            let clickXOnCanvas, clickYOnCanvas;

            if (event.type.startsWith('touch')) {
                if (event.touches.length === 0 && event.changedTouches.length === 0) return; 
                 const touch = event.touches[0] || event.changedTouches[0]; 
                clickXOnCanvas = touch.clientX - rect.left;
                clickYOnCanvas = touch.clientY - rect.top;
            } else { 
                clickXOnCanvas = event.clientX - rect.left;
                clickYOnCanvas = event.clientY - rect.top;
            }
            
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const logicalClickX = clickXOnCanvas * scaleX; 
            const logicalClickY = clickYOnCanvas * scaleY; 

            const screenCellX = Math.floor(logicalClickX / cellSize);
            const screenCellY = Math.floor(logicalClickY / cellSize);

            const x = (screenCellX + offsetX + boardSize) % boardSize; 
            const y = (screenCellY + offsetY + boardSize) % boardSize; 

            if (x < 0 || x >= boardSize || y < 0 || y >= boardSize) return; 
            
            if (isValidMove(x, y, currentPlayer)) {
                processMove(x, y); 
            }
        }

        function isValidMove(x, y, player) {
            if (board[y][x] !== EMPTY) { 
                showMessage("errorStoneExists"); 
                return false;
            }

            // Check against Ko restriction set by the opponent's previous move
            if (koPosition && koPosition.x === x && koPosition.y === y) {
                showMessage("errorKo"); 
                return false;
            }

            const tempBoard = JSON.parse(JSON.stringify(board)); 
            tempBoard[y][x] = player; 
            
            let capturesOpponent = false; 
            const opponent = player === BLACK ? WHITE : BLACK;
            const neighbors = getNeighbors(x, y); 

            for (const n of neighbors) {
                if (tempBoard[n.y][n.x] === opponent) {
                    const opponentGroup = getGroup(n.x, n.y, tempBoard, opponent);
                    if (opponentGroup.liberties === 0) {
                        capturesOpponent = true; 
                        opponentGroup.stones.forEach(s => tempBoard[s.y][s.x] = EMPTY);
                    }
                }
            }
            
            const ownGroup = getGroup(x, y, tempBoard, player); 
            if (ownGroup.liberties === 0 && !capturesOpponent) { 
                showMessage("errorSuicide"); 
                return false; 
            }

            clearMessage(); 
            return true; 
        }

        function getGroup(startX, startY, currentBoard = board, stoneColor = null) {
            if (startY < 0 || startY >= boardSize || startX < 0 || startX >= boardSize) {
                return { stones: [], liberties: 0, color: EMPTY }; 
            }

            const colorToFind = stoneColor !== null ? stoneColor : currentBoard[startY][startX];
            if (colorToFind === EMPTY) return { stones: [], liberties: 0, color: EMPTY }; 

            const q = [{x: startX, y: startY}]; 
            const groupStones = []; 
            const libertyCoords = new Set(); 
            const visited = Array(boardSize).fill(null).map(() => Array(boardSize).fill(false)); 
            
            if(currentBoard[startY][startX] !== colorToFind) { 
                return { stones: [], liberties: 0, color: colorToFind }; 
            }
            visited[startY][startX] = true;

            while (q.length > 0) {
                const {x, y} = q.shift(); 
                groupStones.push({x, y});

                const neighbors = getNeighbors(x, y); 
                for (const n of neighbors) {
                    if (currentBoard[n.y][n.x] === EMPTY) { 
                        libertyCoords.add(`${n.x},${n.y}`); 
                    } else if (currentBoard[n.y][n.x] === colorToFind && !visited[n.y][n.x]) { 
                        visited[n.y][n.x] = true;
                        q.push(n); 
                    }
                }
            }
            return { stones: groupStones, liberties: libertyCoords.size, color: colorToFind };
        }
        
        function removeGroup(stones) { 
            stones.forEach(s => {
                board[s.y][s.x] = EMPTY; 
            });
        }

        function getNeighbors(x, y) { 
            const neighbors = [];
            neighbors.push({x: (x - 1 + boardSize) % boardSize, y: y}); 
            neighbors.push({x: (x + 1) % boardSize, y: y});             
            neighbors.push({x: x, y: (y - 1 + boardSize) % boardSize}); 
            neighbors.push({x: x, y: (y + 1) % boardSize});             
            return neighbors;
        }

        function updateInfo() {
            const t = translations[currentLanguage]; 
            currentPlayerDisplay.textContent = t.currentPlayer + (currentPlayer === BLACK ? t.black : t.white);
            blackCapturedDisplay.textContent = t.blackCaptured + capturedStones[BLACK];
            whiteCapturedDisplay.textContent = t.whiteCaptured + capturedStones[WHITE];
        }
        
        function showMessage(messageKey) { 
            const t = translations[currentLanguage];
            messageArea.textContent = t[messageKey] || messageKey; 
        }

        function clearMessage() {
            messageArea.textContent = "";
        }

        function resetBoard(newSize) { 
            // Only show confirm modal if there are moves in history beyond the initial state
            if (currentHistoryIndex > 0) { 
                showResetConfirmModal(() => { 
                    boardSize = newSize;
                    initBoard(); 
                });
            } else { // If board is empty (or only initial state exists), reset directly
                boardSize = newSize;
                initBoard();
            }
        };
        
        reset9x9Btn.onclick = () => resetBoard(9);
        reset13x13Btn.onclick = () => resetBoard(13);
        reset19x19Btn.onclick = () => resetBoard(19);

        langRadios.forEach(radio => {
            radio.addEventListener('change', (event) => {
                setLanguage(event.target.value);
            });
        });

        undoBtn.onclick = undoMove;
        redoBtn.onclick = redoMove;

        canvas.addEventListener('keydown', (event) => {
            let scrolled = false; 
            switch (event.key) {
                case 'ArrowUp': offsetY = (offsetY - 1 + boardSize) % boardSize; scrolled = true; break; 
                case 'ArrowDown': offsetY = (offsetY + 1) % boardSize; scrolled = true; break; 
                case 'ArrowLeft': offsetX = (offsetX - 1 + boardSize) % boardSize; scrolled = true; break; 
                case 'ArrowRight': offsetX = (offsetX + 1) % boardSize; scrolled = true; break; 
            }
            if (scrolled) {
                event.preventDefault(); 
                drawBoard(); 
            }
        });

        scrollUpBtn.addEventListener('click', () => { 
            offsetY = (offsetY - 1 + boardSize) % boardSize; 
            drawBoard();
            canvas.focus(); 
        });
        scrollDownBtn.addEventListener('click', () => { 
            offsetY = (offsetY + 1) % boardSize; 
            drawBoard();
            canvas.focus();
        });
        scrollLeftBtn.addEventListener('click', () => { 
            offsetX = (offsetX - 1 + boardSize) % boardSize; 
            drawBoard();
            canvas.focus();
        });
        scrollRightBtn.addEventListener('click', () => { 
            offsetX = (offsetX + 1) % boardSize; 
            drawBoard();
            canvas.focus();
        });

        canvas.addEventListener('click', handleInteraction); 

        let tapTimeout = null; 
        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) { 
                touchStartX = e.touches[0].clientX; 
                touchStartY = e.touches[0].clientY;
                tapTimeout = setTimeout(() => { 
                    tapTimeout = null; 
                }, 200); 
            }
        }, { passive: true }); 

        canvas.addEventListener('touchend', (e) => {
            if (tapTimeout) { 
                clearTimeout(tapTimeout); 
                tapTimeout = null;
                const touchEndX = e.changedTouches[0].clientX; 
                const touchEndY = e.changedTouches[0].clientY;
                const deltaX = Math.abs(touchEndX - touchStartX); 
                const deltaY = Math.abs(touchEndY - touchStartY);
                if (deltaX < tapThreshold && deltaY < tapThreshold) { 
                    handleInteraction(e); 
                }
            }
        }, { passive: true });

        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout); 
            resizeTimeout = setTimeout(initBoard, 250); 
        });
        
        loadLanguagePreference(); 
        initBoard(); 
        canvas.focus(); 
    </script>
</body>
</html>
